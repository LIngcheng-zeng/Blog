<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring的事务管理总结</title>
    <url>/blog/posts/c95d5afb/</url>
    <content><![CDATA[<h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1><h2 id="Spring-提供的支持"><a href="#Spring-提供的支持" class="headerlink" title="Spring 提供的支持"></a>Spring 提供的支持</h2><table>
<thead>
<tr>
<th align="left">Action</th>
<th align="left">Spring</th>
<th align="left">You</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Define connection parameters.</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Open the connection.</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Specify the SQL statement.</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Declare parameters and provide parameter values</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Prepare and run the statement.</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Set up the loop to iterate through the results (if any).</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Do the work for each iteration.</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">Process any exception.</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Handle transactions.</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Close the connection, the statement, and the resultset.</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Transaction-Management"><a href="#Transaction-Management" class="headerlink" title="Transaction Management"></a>Transaction Management</h2><p>The key to the Spring transaction abstraction is the notion of a transaction strategy. </p>
<p>事务策略由事务管理器定义：</p>
<p>TransactionDefinition 的属性包括事务的 Propagation，Isolation，Timeout，Read-only status。</p>
<p> the <code>org.springframework.transaction.PlatformTransactionManager</code> interface for imperative transaction management and</p>
<p> the <code>org.springframework.transaction.ReactiveTransactionManager</code> interface for reactive transaction management. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>TransactionStatus</code> interface provides a simple way for transactional code to <strong>control transaction execution</strong> and <strong>query transaction status</strong> .</p>
<h2 id="PlatformTransactionManager-的在jdbc包的几种实现"><a href="#PlatformTransactionManager-的在jdbc包的几种实现" class="headerlink" title="PlatformTransactionManager 的在jdbc包的几种实现"></a>PlatformTransactionManager 的在jdbc包的几种实现</h2><h3 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h3><p>只要设置使用 javax.sql.DataSource 作为其连接工厂机制，此类就可以在任何环境中使用任何 JDBC 驱动程序工作。</p>
<p>This transaction manager supports nested transactions via the JDBC 3.0 <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/Savepoint.html?is-external=true"><code>Savepoint</code></a> mechanism.</p>
<p>This transaction manager can be used as a replacement for the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/jta/JtaTransactionManager.html"><code>JtaTransactionManager</code></a> in the single resource case。</p>
<h2 id="PlatformTransactionManager-的在tx包的几种实现"><a href="#PlatformTransactionManager-的在tx包的几种实现" class="headerlink" title="PlatformTransactionManager 的在tx包的几种实现"></a>PlatformTransactionManager 的在tx包的几种实现</h2><h3 id="AbstractPlatformTransactionManager-承担的角色"><a href="#AbstractPlatformTransactionManager-承担的角色" class="headerlink" title="AbstractPlatformTransactionManager 承担的角色"></a>AbstractPlatformTransactionManager 承担的角色</h3><ul>
<li>determines if there is an existing transaction;</li>
<li>applies the appropriate propagation behavior;</li>
<li>suspends and resumes transactions if necessary;</li>
<li>checks the rollback-only flag on commit;</li>
<li>applies the appropriate modification on rollback (actual rollback or setting rollback-only);</li>
<li>triggers registered synchronization callbacks (if transaction synchronization is active).</li>
</ul>
<h3 id="JtaTransactionManager"><a href="#JtaTransactionManager" class="headerlink" title="JtaTransactionManager"></a>JtaTransactionManager</h3><p>该事务管理器适用于处理分布式事务，即跨越多个资源的事务，以及控制应用服务器资源（例如 JNDI 中可用的 JDBC 数据源）上的事务。</p>
<h3 id="WebLogicJtaTransactionManager"><a href="#WebLogicJtaTransactionManager" class="headerlink" title="WebLogicJtaTransactionManager"></a>WebLogicJtaTransactionManager</h3><p>在 WebLogic 的事务协调器上支持 Spring 事务定义的全部功能，超出标准 JTA：事务名称、每个事务的隔离级别以及在所有情况下正确恢复事务。用于Oracle 平台</p>
<h3 id="WebSphereUowTransactionManager"><a href="#WebSphereUowTransactionManager" class="headerlink" title="WebSphereUowTransactionManager"></a>WebSphereUowTransactionManager</h3><p>用于IBM平台</p>
<h3 id="CciLocalTransactionManager"><a href="#CciLocalTransactionManager" class="headerlink" title="CciLocalTransactionManager"></a>CciLocalTransactionManager</h3><h2 id="Transaction-bound-Events"><a href="#Transaction-bound-Events" class="headerlink" title="Transaction-bound Events"></a>Transaction-bound Events</h2><p>Spring 4.2 之后事件的侦听器可以绑定到事务的一个阶段。 典型的例子是在事务成功完成时处理事件。 当当前事务的结果实际上对侦听器很重要时，这样做可以更灵活地使用事件。</p>
<h2 id="PlatformTransactionManager-实现分析"><a href="#PlatformTransactionManager-实现分析" class="headerlink" title="PlatformTransactionManager 实现分析"></a>PlatformTransactionManager 实现分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//This implementation handles propagation behavior. Delegates to doGetTransaction,isExistingTransaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">   TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line">   Object transaction = doGetTransaction();</span><br><span class="line">   <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">      <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">      <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line">   <span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">   <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">         def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">      SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">         DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">               def, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">         doBegin(transaction, def);</span><br><span class="line">         prepareSynchronization(status, def);</span><br><span class="line">         <span class="keyword">return</span> status;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">         resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">      <span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">         logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">               <span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">      <span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot下业务Bean的生成过程跟踪</title>
    <url>/blog/posts/80587bc/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="SpringBoot-下-业务Bean的生成过程跟踪"><a href="#SpringBoot-下-业务Bean的生成过程跟踪" class="headerlink" title="SpringBoot 下 业务Bean的生成过程跟踪"></a>SpringBoot 下 业务Bean的生成过程跟踪</h1><p>首先 Bean 是 Java 对象，然后才是Bean。Bean 的依赖注入，也就是 对象的属性 进行 赋值的过程。</p>
<p>对象有成员属性，成员属性有基本类型的，有的成员本身也是一个对象。</p>
<p>基本类型的注入可以通过PropertiesSource进行注入，</p>
<p>对象类型的则通过Bean注入。</p>
<span id="more"></span>

<h2 id="JVM-中对象的生成过程"><a href="#JVM-中对象的生成过程" class="headerlink" title="JVM 中对象的生成过程"></a>JVM 中对象的生成过程</h2><p>类在虚拟机中的生命周期 <strong>依次</strong> 经历 类的 加载，验证，准备和初始化以及卸载。对象是在类初始化之后的产物。参考《深入理解Java虚拟机 - 周志明》相关过程如下</p>
<h3 id="类初始化阶段"><a href="#类初始化阶段" class="headerlink" title="类初始化阶段"></a>类初始化阶段</h3><p>这个阶段就是执行<code>&lt;clinit&gt;()</code>方法的过程。这个方法是Javac编译器的产物。用函数的形式表示这个过程：  <code>clinit()</code> = Javac(XX.class)</p>
<p>具体的函数过程如下</p>
<ol>
<li>所有类变量的 <strong>赋值动作（这里说的是赋值语句，不包括构造函数）</strong> 和静态语句块。收集顺序等于源文件中定义的顺序。</li>
<li>在触发父类初始化的前提下，父类的<code>clinit()</code>先于子类执行。</li>
<li><code>clinit()</code>方法是可选的</li>
<li>Java虚拟机保证多个线程同时去初始化一个类时，该类的<code>clinit()</code>方法仅执行一次。</li>
</ol>
<h3 id="构造对象阶段"><a href="#构造对象阶段" class="headerlink" title="构造对象阶段"></a>构造对象阶段</h3><p>对象的生命周期</p>
<ol>
<li>为创建的对象分配堆上空间</li>
<li>对象的属性执行初始化为零值的过程。</li>
<li>设置对象的对象头。</li>
<li>执行.class文件的<code>init()</code>函数，也就是类的构造函数</li>
</ol>
<p>至此，对象才是一个可引用（也就是可以被应用程序访问）的对象。</p>
<p>当类的构造函数中出现循环依赖时，将无法完成对象的构造过程。</p>
<h2 id="Spring生成业务Bean的过程"><a href="#Spring生成业务Bean的过程" class="headerlink" title="Spring生成业务Bean的过程"></a>Spring生成业务Bean的过程</h2><p><code>ApplicationContext</code> 代表了容纳Bean的容器，我们将程序所需要的基本功能单元，放到容器之中。在需要时，容器帮我们取出，进行赋值。通过组合基本功能单元，我们实现了应用程序的功能。</p>
<p>因此，大致的过程应该如下</p>
<p>定义基本功能单元 ，将定义的基本功能单元从程序代码中寻找出来，然后将之放于容器之中。然后我们定义自己需要什么，并且告诉容器。容器按需找出定义的基本功能单元，完成注入的过程。</p>
<p>参考 <a href="https://lingcheng-zeng.github.io/blog/posts/60de195c/#more">启动内置tomcat容器</a> 一文中的<code>refresh()</code>方法的分析，寻找Bean定义的过程 是  <code>invokeBeanFactoryPostProcessors()</code>执行的过程，业务Bean的实例化发生在<code>finishBeanFactoryInitialization()</code>方法中。 </p>
<h3 id="什么是基本的功能单元-BeanDefinition"><a href="#什么是基本的功能单元-BeanDefinition" class="headerlink" title="什么是基本的功能单元 - BeanDefinition"></a>什么是基本的功能单元 - BeanDefinition</h3><p>xml中的<bean> 标签 转化为 beanDefinition ，描述了 bean的 依赖项，生命周期，回调 等。xml存在于文件中，BeanDefinition存在于内存中</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/bedifinitionCreateProgress-20211009140636492.png" alt="image-20211009140636492"></p>
<h3 id="如何找到需要放到容器中的-BeanDefinition"><a href="#如何找到需要放到容器中的-BeanDefinition" class="headerlink" title="如何找到需要放到容器中的 BeanDefinition"></a>如何找到需要放到容器中的 BeanDefinition</h3><p>用注解描述的配置 以及 用xml描述的配置 经过解析后 将 BeanDefinition存放于 DefaultListableBeanFactory 的 beanDefinitionMap 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultListableBeanFactory 作为 注册和加载Bean的基本实现</span><br><span class="line">	/** Map of bean definition objects, keyed by bean name. */</span><br><span class="line">	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br></pre></td></tr></table></figure>

<h3 id="如何进行Bean的实例化"><a href="#如何进行Bean的实例化" class="headerlink" title="如何进行Bean的实例化"></a>如何进行Bean的实例化</h3><ol>
<li><h4 id="何时"><a href="#何时" class="headerlink" title="何时"></a>何时</h4><p>1. </p>
</li>
<li><h4 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h4><p>getObjectFromBeanInstance: 从初始的BeanInstance 中 获取 应用程序 预期的 bean。</p>
<p>aop增强后的Bean </p>
<p>获取工厂本身的实例 还是获取  用工厂创建的实例 ，通过&amp; 区分，&amp;beanName 代表去工厂自身，beanName 代表取 用工厂创建出的实例。</p>
<p>Scope的角度</p>
<ol>
<li>Singleton</li>
<li>ProtoType</li>
<li>Other Scope</li>
</ol>
<p>另一种区分的角度是FactoryBean 还是 normal Bean</p>
</li>
</ol>
<p>反射调用无参构造  - - &gt; setter 注入</p>
<p>@Autowired 注入的原理</p>
<p>参考：<a href="https://www.jianshu.com/p/1002f5a704ea">https://www.jianshu.com/p/1002f5a704ea</a></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Bean</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>应用程序间的数据交换</title>
    <url>/blog/posts/9b67a8b0/</url>
    <content><![CDATA[<h1 id="应用间的数据交换"><a href="#应用间的数据交换" class="headerlink" title="应用间的数据交换"></a>应用间的数据交换</h1><p>应用间的数据交换，本质上是内存中的数据转化为字节流从一端流向另一端，历经    内存 – 网络/磁盘 – 内存 这一路径，涉及序列化，数据传输，反序列化等过程。</p>
<p>开发的应用程序通常构建在应用层之上，也就是说应用程序在进行数据传输时会受到如下各层协议的影响。</p>
<ol>
<li>应用层协议的影响</li>
<li>传输层协议的影响</li>
<li>网络层协议的影响</li>
<li>链路层，物理层的影响</li>
</ol>
<p>例如</p>
<p>浏览器通过http协议与服务端的通信。</p>
<p>后端服务间通过TCP或者HTTP或者一些其他的协议进行通信。</p>
<p>所以，要对已有的数据交换过程进行优化，也就是要对原有的交换链路进行评估和优化。netty 加快了数据的处理时间【单位时间内可以处理更多的请求】，使得网络可以更快的传输数据。不同的序列化协议，一个是要考虑执行序列化花费的时间，二是考虑序列化后数据的大小。</p>
<p>链接：从缓存到应用进程  <a href="https://github.com/rabbitmq/rabbitmq-server.git">https://github.com/rabbitmq/rabbitmq-server.git</a></p>
<span id="more"></span>





<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h4><p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/HTTP%E4%BA%8B%E5%8A%A1%E6%97%B6%E5%BB%B6.png" alt="截屏2021-07-05 下午9.24.43"></p>
<h4 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h4><p>只有特定的人才可以看到敏感信息，并执行特权事务。</p>
<p>http的原生认证，包括基本认证和摘要认证。</p>
<p>基本认证的主要流程如下：</p>
<p>服务器返回401状态码进行质询，并用www-Authenticate 首部，指明所访问的受限资源。</p>
<p>客户端用authorization,表明身份，去服务器获取授权。</p>
<p>摘要认证：</p>
<p>计算单向摘要,默认算法为Md5.</p>
<p>接受任意长度的消息，产生一个128bit的摘要。然后用16进制数对其进行表示，也就是每4bit产生一个16进制的数。因此可视化的结果是32个16进制数的组合。</p>
<p>16进制：0，1，2，3 … ,A,B,C,D,E</p>
<p>Base64, 基本字母有64个。</p>
<p>怎么把原字符转换为用基本字母表示的字符</p>
<p>原字符 ，8bit。</p>
<p>64个字母，只需要 6bit就能表示。 当原字符长度不够时，用0的二进制位补齐。</p>
<p>Https</p>
<p>对称密钥加密技术：指的是编码所使用的密钥值和解码所使用的密钥值相同。</p>
<p>公开密钥加密技术：公开编码的密钥，接受端保留解码的密钥，两个密钥不相同。RSA算法是流行的一种。</p>
<p>混合对称和非对称加密：通过公开密钥技术建立起安全的连接通道，然后传递一个随机对称密钥，利用对称密钥技术进行通信。</p>
<p>加密算法是众所周知的。</p>
<p>密钥，使加密算法按照期待的过程执行。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 套接字状态 ,含义 </span></span><br><span class="line">   State</span><br><span class="line">       The state of the socket. Since there are no states <span class="keyword">in</span> raw mode and usually no states used <span class="keyword">in</span> UDP and UDPLite, this column may be left blank.</span><br><span class="line">       Normally this can be one of several values:</span><br><span class="line"></span><br><span class="line">       ESTABLISHED</span><br><span class="line">              The socket has an established connection.</span><br><span class="line"></span><br><span class="line">       SYN_SENT</span><br><span class="line">              The socket is actively attempting to establish a connection.</span><br><span class="line"></span><br><span class="line">       SYN_RECV</span><br><span class="line">              A connection request has been received from the network.</span><br><span class="line"></span><br><span class="line">       FIN_WAIT1</span><br><span class="line">              The socket is closed, and the connection is shutting down.</span><br><span class="line"></span><br><span class="line">       FIN_WAIT2</span><br><span class="line">              Connection is closed, and the socket is waiting <span class="keyword">for</span> a shutdown from the remote end.</span><br><span class="line"></span><br><span class="line">       TIME_WAIT</span><br><span class="line">              The socket is waiting after close to handle packets still <span class="keyword">in</span> the network.</span><br><span class="line"></span><br><span class="line">       CLOSE  The socket is not being used.</span><br><span class="line"></span><br><span class="line">       CLOSE_WAIT</span><br><span class="line">              The remote end has shut down, waiting <span class="keyword">for</span> the socket to close.</span><br><span class="line"></span><br><span class="line">       LAST_ACK</span><br><span class="line">              The remote end has shut down, and the socket is closed. Waiting <span class="keyword">for</span> acknowledgement.</span><br><span class="line"></span><br><span class="line">       LISTEN The socket is listening <span class="keyword">for</span> incoming connections.  Such sockets are not included <span class="keyword">in</span> the output unless  you  specify  the  --listening</span><br><span class="line">              (-l) or --all (-a) option.</span><br><span class="line"></span><br><span class="line">       CLOSING</span><br><span class="line">              Both sockets are shut down but we still don<span class="string">&#x27;t have all our data sent.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       UNKNOWN</span></span><br><span class="line"><span class="string">              The state of the socket is unknown</span></span><br></pre></td></tr></table></figure>



<h4 id="建立连接-三次握手"><a href="#建立连接-三次握手" class="headerlink" title="建立连接- 三次握手"></a>建立连接- 三次握手</h4><p>CLOSED -   SYN-SENT - ESTABLIASHED </p>
<p>CLOSED -   LISTEN - SYN-RECV - ESTABLISH </p>
<p>建立连接是为了什么，第一点，要是双方能确知对方的存在。第二点，要允许双方协商一些参数；第三，能够对运输资源进行分配【包括缓存大小，连接表中的项目等】</p>
<p>两次行不行:   可以，但是计算机 运输资源是有限的，在已失效的连接请求报文段，到达服务器端时，会造成服务端传输资源的浪费。也就是，服务端在接受到请求报文时，不能确认这个请求时是现在的请求还是在网络中延迟的无效请求。</p>
<p>三次行不行：为了解决这个问题，只需要向客户端确认是不是此时是否建立连接，如果确实要建立，就发送一次确认报文；如果不是，就不用理会了。服务端就知道这个请求报文时延迟到达的无效报文。</p>
<h4 id="释放连接-四次握手"><a href="#释放连接-四次握手" class="headerlink" title="释放连接 - 四次握手"></a>释放连接 - 四次握手</h4><p>终止双向传输的通信</p>
<ol>
<li>第一个发起终止的状态转变：ESTABLISHED- FIN-WAIT-1-FIN-WAIT2-TIME-WAIT-CLOSED</li>
<li>第二个发起终止的状态转变：ESTABLISHED - CLOSE-WAIT-LAST-ACK- CLOSED</li>
</ol>
<p>解释状态迁移图中各状态的含义，以及状态存在的意义</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B.png" alt="截屏2021-07-04 下午12.21.08"></p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/TCP%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80.png" alt="截屏2021-07-04 下午12.22.35"></p>
<h4 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h4><p>源端口和目的端口各占两个字节。</p>
<p>首部中的序号，本报文段的第一个字节的编号，占4个字节 ，也就是4GB的数据编号不会重复。在一个TCP连接中的所有字节流的按照写入顺序编号 。</p>
<p>确认号，期望收到的对方下一个报文段的第一个字节的序列号。在确认报文中进行设置，也是占4个字节。</p>
<p>数据偏移，指示出TCP首部的长度，占4bit。 数据偏移的单位是4个字节。因此首部长度 最大为 4 * 15 = 60</p>
<p>保留，占6bit。</p>
<p>URG,</p>
<p>ACK , </p>
<p>PSH,</p>
<p>RST</p>
<p>SYN</p>
<p>FIN</p>
<p>窗口，占两个字节。自确认号算起，告诉发送方还可以发送的数据量，单位是字节。【自己作为接受的一方，对对面的发送进行限制】</p>
<p>检验和，校验首部和数据部分，占两个字节。</p>
<p>紧急指针，指示URG =1 时，在本次报文段中紧急数据的长度。窗口之为0，也可以发送紧急数据</p>
<h4 id="TCP可靠传输原理"><a href="#TCP可靠传输原理" class="headerlink" title="TCP可靠传输原理"></a>TCP可靠传输原理</h4><p>滑动窗口，超时重传，选择确认。</p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>Ack =1 时，确认号字段有意义。持续计时器，解决0窗口后，窗口变化，报文丢失导致死锁的问题。</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%91%E9%80%81TCP%E6%8A%A5%E6%96%87.png" alt="截屏2021-07-02 上午10.59.53"></p>
<h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><p>慢开始</p>
<p>拥塞避免</p>
<p>快重传</p>
<p>快恢复</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="截屏2021-07-02 下午1.56.17"></p>
<h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a><strong>因特网概述</strong></h3><p>所有的设备称为端系统，端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p>
<p>这里的通信链路指的是实际的物理媒体。</p>
<p>分组交换机从它的一条入通信链路接受到达的分组，并从它的一条出通信链路转发该分组。对于每条相连的链路，该分组交换机具有一个输出缓存，它用于存储准备发往该链路的分组。多数交换机在链路的输入端使用存储转发传输机制，也就是指在交换机开始向输出链路转发某个分组的第一个bit前，必须完整的收到这个分组。</p>
<p>端系统，分组交换机和一些其他的因特网部件都要运行一系列协议，这些协议控制因特网中消息的接受和发送。</p>
<p>每台路由器都有一个<strong>转发表</strong>。路由器检测到达分组首部的一个或者多个字段，然后使用这些首部值在其转发表中索引，通过这种方式来转发分组。</p>
]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>应用层协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Web请求处理链路跟踪</title>
    <url>/blog/posts/fe149bac/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis组件分析</title>
    <url>/blog/posts/550e64fc/</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="使用Mybatis时的组件依赖"><a href="#使用Mybatis时的组件依赖" class="headerlink" title="使用Mybatis时的组件依赖"></a>使用Mybatis时的组件依赖</h2><p>应用程序 –&gt;  mybatis  –&gt;  com.mysql.cj.jdbc –&gt;mysql</p>
<p>应用程序 –&gt;  Spring    –&gt; mybatis –&gt; com.mysql.cj.jdbc –&gt; mysql 【驱动器为com.mysql.cj.jdbc.Driver 时】</p>
<h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>Java JDBC API  的设计思想：根据API 编写的应用都可以与驱动管理器进行通信，而驱动管理器则通过驱动程序与实际的数据库进行通信。，JDBC使得我们可以通过SQL与数据库进行通信。我们可以将JDBC包看作是一个用于将SQL语句传递给数据库的API。</p>
<p>API 包名：java.sql 和 javax.sql </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Client] --&gt;|http|B[Bussinees Service]</span><br><span class="line">    B --&gt; C[JDBC API]</span><br><span class="line">    C --&gt;|protocol| D[DataBase Server]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Mybatis-ORM"><a href="#Mybatis-ORM" class="headerlink" title="Mybatis ORM"></a>Mybatis ORM</h2><p>ORM，创建了一个虚拟对象数据库，将面向对象的设计 与 面向关系的数据库 桥接起来 ，使得开发者可以用面向对象的理念来操作数据库。 为了实现这个目的，就需要将对象上执行的操作将其转换为对数据库的操作。</p>
<p>例如 person.setName(“Demo”) , person 的标识id 为 1 需要想办法将其转化为 update person  name = “Demo” where id = 1</p>
<p>mybatis 中 可以被转化的对象 称之为 Mapper   ,  函数的操作所绑定的sql 写在 对应的mapper.xml 中,两者通过nameSpace绑定起来。通过 mapper.xml 中的id 与 对象上的操作绑定。这两者的绑定是静态的，实现了动作到模版sql语句的转换。然后通过封装JDBC， 解决将模版中的参数进行具体化以执行真正的sql, 以及 将查询的结果存储在对象中的问题。</p>
<h2 id="数据库相关的组件分析"><a href="#数据库相关的组件分析" class="headerlink" title="数据库相关的组件分析"></a>数据库相关的组件分析</h2><p>Drive Manage，DataSource , Connection , Transaction , Statement 【PreparedStatement 】, ResultSet </p>
<h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment =  <span class="keyword">new</span> Environment(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line">SqlSessionFactory sqlSessionFactory =  <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = session.selectOne(</span><br><span class="line">    <span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span><br><span class="line">  &lt;select id=<span class="string">&quot;selectBlog&quot;</span> resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h3 id="mybatis-Fast-QA"><a href="#mybatis-Fast-QA" class="headerlink" title="mybatis Fast QA"></a>mybatis Fast QA</h3><ol>
<li>一些组件的生命周期：SqlSessionFactoryBuilder，SqlSessionFactory，SqlSession，Mapper Instances</li>
<li>一些改变mybatis运行时的setting。<a href="https://mybatis.org/mybatis-3/configuration.html#settings">https://mybatis.org/mybatis-3/configuration.html#settings</a></li>
</ol>
<h2 id="使用Mybatis-Spring"><a href="#使用Mybatis-Spring" class="headerlink" title="使用Mybatis-Spring"></a>使用Mybatis-Spring</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    factoryBean.setDataSource(dataSource());</span><br><span class="line">    <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">getUser</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> String userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserMapper <span class="title">userMapper</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionTemplate sqlSessionTemplate = <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory());</span><br><span class="line">    <span class="keyword">return</span> sqlSessionTemplate.getMapper(UserMapper.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooServiceImpl</span> <span class="keyword">implements</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">doSomeBusinessStuff</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.getUser(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Mybatis-源码包结构概览"><a href="#Mybatis-源码包结构概览" class="headerlink" title="Mybatis 源码包结构概览"></a>Mybatis 源码包结构概览</h2><table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>Type Handlers</td>
</tr>
<tr>
<td>transaction</td>
<td>Base package for transactions</td>
</tr>
<tr>
<td>Session</td>
<td>Base package. Contains the SqlSession</td>
</tr>
<tr>
<td>Mapping</td>
<td>Base package for mapping.   包括参数映射， 结果集映射</td>
</tr>
<tr>
<td>logging</td>
<td>Base package for logging.</td>
</tr>
<tr>
<td>Lang</td>
<td>Java Language Package</td>
</tr>
<tr>
<td>io</td>
<td>Utilities to read resources</td>
</tr>
<tr>
<td>Executor</td>
<td>Contains the statement executors</td>
</tr>
<tr>
<td>Exceptions</td>
<td>Base package for exceptions</td>
</tr>
<tr>
<td>Datasources</td>
<td>Base package for Datasources</td>
</tr>
<tr>
<td>Cursor</td>
<td>Base package for cursor feature.</td>
</tr>
<tr>
<td>Cache</td>
<td>Base package for caching stuff.</td>
</tr>
<tr>
<td>Builder</td>
<td>Base package for the Configuration building code</td>
</tr>
<tr>
<td>binding</td>
<td>Bings mapper interfaces with mapped statements</td>
</tr>
<tr>
<td>annotations</td>
<td>Contains all the annotation that are used in mapper interfaces.</td>
</tr>
<tr>
<td>scripting</td>
<td>Base package for languages</td>
</tr>
</tbody></table>
<h2 id="mybatis-组件角色分析"><a href="#mybatis-组件角色分析" class="headerlink" title="mybatis 组件角色分析"></a>mybatis 组件角色分析</h2><h3 id="ParameterMapping-与-ResultMapping"><a href="#ParameterMapping-与-ResultMapping" class="headerlink" title="ParameterMapping 与 ResultMapping"></a>ParameterMapping 与 ResultMapping</h3><p>代表了参数字段处理和返回值字段处理的逻辑，对于非基本类型，比如对象和数组，需要自己处理一下参数，将非基本类型转化为String【比如JSON 格式的String】，在获取结果集时再将String 转化为对应的类型结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于处理sql参数中的一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterMapping</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> String property;</span><br><span class="line">  <span class="keyword">private</span> ParameterMode mode;<span class="comment">//用于处理可调用语句的输出</span></span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; javaType = Object.class;</span><br><span class="line">  <span class="keyword">private</span> JdbcType jdbcType; </span><br><span class="line">  <span class="keyword">private</span> Integer numericScale;</span><br><span class="line">  <span class="keyword">private</span> TypeHandler&lt;?&gt; typeHandler;<span class="comment">// Used when setting parameters to the PreparedStatement.</span></span><br><span class="line">  <span class="keyword">private</span> String resultMapId;</span><br><span class="line">  <span class="keyword">private</span> String jdbcTypeName;</span><br><span class="line">  <span class="keyword">private</span> String expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParameterMap-与-ResultMap"><a href="#ParameterMap-与-ResultMap" class="headerlink" title="ParameterMap 与 ResultMap"></a>ParameterMap 与 ResultMap</h3><p>代表了一条语句所有参数处理和返回值字段处理的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于处理完整的 sql参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MappedStatement"><a href="#MappedStatement" class="headerlink" title="MappedStatement"></a>MappedStatement</h3><p>代表了一个完整的语句处理环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedStatement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String resource;</span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Integer fetchSize;</span><br><span class="line">  <span class="keyword">private</span> Integer timeout;</span><br><span class="line">  <span class="keyword">private</span> StatementType statementType;<span class="comment">//STATEMENT, PREPARED, CALLABLE</span></span><br><span class="line">  <span class="keyword">private</span> ResultSetType resultSetType;<span class="comment">//DEFAULT ,FORWARD_ONLY,SCROLL_INSENSITIVE,SCROLL_SENSITIVE</span></span><br><span class="line">  <span class="keyword">private</span> SqlSource sqlSource; <span class="comment">//Represents the content of a mapped statement read from an XML file or an annotation.</span></span><br><span class="line">  <span class="keyword">private</span> Cache cache;<span class="comment">//One instance of cache will be created for each namespace. The cache implementation must have a constructor that receives the cache id as an String parameter. MyBatis will pass the namespace as id to the constructor.</span></span><br><span class="line">  <span class="keyword">private</span> ParameterMap parameterMap;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ResultMap&gt; resultMaps;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flushCacheRequired;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useCache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> resultOrdered;</span><br><span class="line">  <span class="keyword">private</span> SqlCommandType sqlCommandType;<span class="comment">//UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH</span></span><br><span class="line">  <span class="keyword">private</span> KeyGenerator keyGenerator;</span><br><span class="line">  <span class="keyword">private</span> String[] keyProperties; <span class="comment">// 包含键值的属性名称，疑似对象的属性名称</span></span><br><span class="line">  <span class="keyword">private</span> String[] keyColumns;<span class="comment">// 检索键值的列名，库表的字段名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">  <span class="keyword">private</span> String databaseId;</span><br><span class="line">  <span class="keyword">private</span> Log statementLog;</span><br><span class="line">  <span class="keyword">private</span> LanguageDriver lang;</span><br><span class="line">  <span class="keyword">private</span> String[] resultSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MapperBuilderAssistant"><a href="#MapperBuilderAssistant" class="headerlink" title="MapperBuilderAssistant"></a>MapperBuilderAssistant</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于帮助构建映射器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperBuilderAssistant</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String currentNamespace;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String resource;</span><br><span class="line">  <span class="keyword">private</span> Cache currentCache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> unresolvedCacheRef; <span class="comment">// issue #676</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      String id,</span></span></span><br><span class="line"><span class="params"><span class="function">      SqlSource sqlSource,</span></span></span><br><span class="line"><span class="params"><span class="function">      StatementType statementType,</span></span></span><br><span class="line"><span class="params"><span class="function">      SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="params"><span class="function">      Integer fetchSize,</span></span></span><br><span class="line"><span class="params"><span class="function">      Integer timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">      String parameterMap,</span></span></span><br><span class="line"><span class="params"><span class="function">      Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="params"><span class="function">      String resultMap,</span></span></span><br><span class="line"><span class="params"><span class="function">      Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="params"><span class="function">      ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="params"><span class="function">      KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="params"><span class="function">      String keyProperty,</span></span></span><br><span class="line"><span class="params"><span class="function">      String keyColumn,</span></span></span><br><span class="line"><span class="params"><span class="function">      String databaseId,</span></span></span><br><span class="line"><span class="params"><span class="function">      LanguageDriver lang,</span></span></span><br><span class="line"><span class="params"><span class="function">      String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;Cache-ref not yet resolved&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    MappedStatement.Builder statementBuilder = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">        .resource(resource)</span><br><span class="line">        .fetchSize(fetchSize)</span><br><span class="line">        .timeout(timeout)</span><br><span class="line">        .statementType(statementType)</span><br><span class="line">        .keyGenerator(keyGenerator)</span><br><span class="line">        .keyProperty(keyProperty)</span><br><span class="line">        .keyColumn(keyColumn)</span><br><span class="line">        .databaseId(databaseId)</span><br><span class="line">        .lang(lang)</span><br><span class="line">        .resultOrdered(resultOrdered)</span><br><span class="line">        .resultSets(resultSets)</span><br><span class="line">        .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">        .resultSetType(resultSetType)</span><br><span class="line">        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">        .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">        .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">      statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MapperAnnotationBuilder"><a href="#MapperAnnotationBuilder" class="headerlink" title="MapperAnnotationBuilder"></a>MapperAnnotationBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 MapperBuilderAssistant，用于处理一个类的所有注解中定义的语句</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperAnnotationBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; statementAnnotationTypes = Stream</span><br><span class="line">      .of(Select.class, Update.class, Insert.class, Delete.class, SelectProvider.class, UpdateProvider.class,</span><br><span class="line">          InsertProvider.class, DeleteProvider.class)</span><br><span class="line">      .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//details</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      loadXmlResource();</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      assistant.setCurrentNamespace(type.getName());</span><br><span class="line">      parseCache();</span><br><span class="line">      parseCacheRef();</span><br><span class="line">      <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">            &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          parseResultMap(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">          configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XMLStatementBuilder"><a href="#XMLStatementBuilder" class="headerlink" title="XMLStatementBuilder"></a>XMLStatementBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 MapperBuilderAssistant，用于处理XML中定义的语句</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLStatementBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant builderAssistant;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> XNode context;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String requiredDatabaseId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MapperRegistry，映射器注册表"><a href="#MapperRegistry，映射器注册表" class="headerlink" title="MapperRegistry，映射器注册表"></a>MapperRegistry，映射器注册表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasMapper</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Class&lt;?&gt;&gt; getMappers()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span></span>&#123;&#125;</span><br><span class="line">  <span class="comment">//details </span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">        <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">        <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过读取配置类创建一个SqlSessionFactory  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="DefaultSqlSessionFactory"><a href="#DefaultSqlSessionFactory" class="headerlink" title="DefaultSqlSessionFactory"></a>DefaultSqlSessionFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Environment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionFactory transactionFactory;<span class="comment">//用于产生事务实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;<span class="comment">// 用于获取连接</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A factory for connections to the physical data source that this DataSource object represents</span></span><br><span class="line"><span class="comment">//An alternative to the DriverManager facility,a DataSource object is the preferred means of getting a connection. </span></span><br><span class="line"><span class="comment">// 一个帮助获取数据库连接的工厂</span></span><br></pre></td></tr></table></figure>

<h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装了一个数据库链接，并处理连接的创建，准备，提交，回滚以及关闭。</span></span><br><span class="line"><span class="comment">// Handles the connection lifecycle that comprises: its creation, preparation, commit/rollback and close.</span></span><br></pre></td></tr></table></figure>

<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于执行命令,获取Mapper ,以及管理事务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行映射的sql语句</span></span><br><span class="line"><span class="comment">//包括：BaseExecutor，BatchExecutor，ReuseExecutor，SimpleExecutor，CachingExecutor</span></span><br><span class="line"><span class="comment">//重点关注：BaseExecutor，SimpleExecutor，BatchExecutor</span></span><br><span class="line"><span class="comment">//SimpleExecutor，BatchExecutor 对 BaseExecutor 的 doXXX 接口进行了实现. XXX 作为钩子被BaseExecutor调用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(BaseExecutor.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Transaction transaction;</span><br><span class="line">  <span class="keyword">protected</span> Executor wrapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line">  <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> queryStack;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现类包括了：BaseStatementHandler，SimpleStatementHandler，PreparedStatementHandler，CallableStatementHandler ,RoutingStatementHandler</span></span><br><span class="line"><span class="comment">// BaseStatementHandler 是几个实现类的基类；RoutingStatementHandler ,用于分发。</span></span><br><span class="line"><span class="comment">// SimpleStatementHandler     运行时不能够接受参数的sql</span></span><br><span class="line"><span class="comment">// PreparedStatementHandler   运行时可以接受参数的sql eg:&quot;Update Employees SET age = ? WHERE id = ?&quot;</span></span><br><span class="line"><span class="comment">//  CallableStatementHandler  使用存储过程访问数据库时使用</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 最终mybatis 的 execute() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.mysql.cj.jdbc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientPreparedStatement</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">StatementImpl</span> <span class="keyword">implements</span> <span class="title">JdbcPreparedStatement</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (checkClosed().getConnectionMutex()) &#123;</span><br><span class="line"></span><br><span class="line">            JdbcConnection locallyScopedConn = <span class="keyword">this</span>.connection;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.doPingInstead &amp;&amp; !checkReadOnlySafeStatement()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;PreparedStatement.20&quot;</span>) + Messages.getString(<span class="string">&quot;PreparedStatement.21&quot;</span>),</span><br><span class="line">                        MysqlErrorNumbers.SQL_STATE_ILLEGAL_ARGUMENT, <span class="keyword">this</span>.exceptionInterceptor);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ResultSetInternalMethods rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.lastQueryIsOnDupKeyUpdate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.retrieveGeneratedKeys) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastQueryIsOnDupKeyUpdate = containsOnDuplicateKeyUpdateInSQL();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.batchedGeneratedKeys = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            resetCancelledState();</span><br><span class="line"></span><br><span class="line">            implicitlyCloseAllOpenResults();</span><br><span class="line"></span><br><span class="line">            clearWarnings();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.doPingInstead) &#123;</span><br><span class="line">                doPingInstead();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setupStreamingTimeout(locallyScopedConn);</span><br><span class="line"></span><br><span class="line">            Message sendPacket = ((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).fillSendPacket();</span><br><span class="line"></span><br><span class="line">            String oldDb = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!locallyScopedConn.getDatabase().equals(<span class="keyword">this</span>.getCurrentDatabase())) &#123;</span><br><span class="line">                oldDb = locallyScopedConn.getDatabase();</span><br><span class="line">                locallyScopedConn.setDatabase(<span class="keyword">this</span>.getCurrentDatabase());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Check if we have cached metadata for this query...</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            CachedResultSetMetaData cachedMetadata = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> cacheResultSetMetadata = locallyScopedConn.getPropertySet().getBooleanProperty(PropertyKey.cacheResultSetMetadata).getValue();</span><br><span class="line">            <span class="keyword">if</span> (cacheResultSetMetadata) &#123;</span><br><span class="line">                cachedMetadata = locallyScopedConn.getCachedMetaData(((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getOriginalSql());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Only apply max_rows to selects</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            locallyScopedConn.setSessionMaxRows(((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getParseInfo().getFirstStmtChar() == <span class="string">&#x27;S&#x27;</span> ? <span class="keyword">this</span>.maxRows : -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            rs = executeInternal(<span class="keyword">this</span>.maxRows, sendPacket, createStreamingResultSet(),</span><br><span class="line">                    (((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getParseInfo().getFirstStmtChar() == <span class="string">&#x27;S&#x27;</span>), cachedMetadata, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cachedMetadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                locallyScopedConn.initializeResultsMetadataFromCache(((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getOriginalSql(), cachedMetadata, rs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.hasRows() &amp;&amp; cacheResultSetMetadata) &#123;</span><br><span class="line">                    locallyScopedConn.initializeResultsMetadataFromCache(((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getOriginalSql(), <span class="keyword">null</span> <span class="comment">/* will be created */</span>, rs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.retrieveGeneratedKeys) &#123;</span><br><span class="line">                rs.setFirstCharOfQuery(((PreparedQuery&lt;?&gt;) <span class="keyword">this</span>.query).getParseInfo().getFirstStmtChar());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oldDb != <span class="keyword">null</span>) &#123;</span><br><span class="line">                locallyScopedConn.setDatabase(oldDb);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastInsertId = rs.getUpdateID();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.results = rs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ((rs != <span class="keyword">null</span>) &amp;&amp; rs.hasRows());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-–-gt-com-mysql-cj-jdbc"><a href="#mybatis-–-gt-com-mysql-cj-jdbc" class="headerlink" title="mybatis –&gt; com.mysql.cj.jdbc"></a>mybatis –&gt; com.mysql.cj.jdbc</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.apache.ibatis.executor.statement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PreparedStatement 作为连接点，调用了下面这个实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientPreparedStatement</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">StatementImpl</span> <span class="keyword">implements</span> <span class="title">JdbcPreparedStatement</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JdbcPreparedStatement</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">PreparedStatement</span>, <span class="title">JdbcStatement</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Query-模版方法"><a href="#Query-模版方法" class="headerlink" title="Query 模版方法"></a>Query 模版方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;<span class="comment">//查询的结果</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//正在进行的查询语句数量+1</span></span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);<span class="comment">//从本地缓存中取</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);<span class="comment">//从数据库查询</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//正在进行的查询语句数量-1</span></span><br><span class="line">    queryStack--;<span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查询数据库的过程"><a href="#查询数据库的过程" class="headerlink" title="查询数据库的过程"></a>查询数据库的过程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SImpleExecutor的doQuery"><a href="#SImpleExecutor的doQuery" class="headerlink" title="SImpleExecutor的doQuery()"></a>SImpleExecutor的<code>doQuery()</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());<span class="comment">// 这个拿取了数据库连接</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Update模版方法"><a href="#Update模版方法" class="headerlink" title="Update模版方法"></a>Update模版方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spring-mybatis"><a href="#Spring-mybatis" class="headerlink" title="Spring-mybatis"></a>Spring-mybatis</h1><ol>
<li>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器类。<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。所指定的映射器类<strong>必须</strong>是一个接口，而不是具体的实现类。</li>
<li>在基础的 MyBatis 用法中，是通过 <code>SqlSessionFactoryBuilder</code> 来创建 <code>SqlSessionFactory</code> 的。而在 MyBatis-Spring 中，则使用 <code>SqlSessionFactoryBean</code> 来创建。</li>
<li>一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 <code>DataSourceTransactionManager</code> 来实现事务管理。注意：为事务管理器指定的 <code>DataSource</code> <strong>必须</strong>和用来创建 <code>SqlSessionFactoryBean</code> 的是同一个数据源，否则事务管理器就无法工作了。</li>
<li><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。   <code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</li>
</ol>
<h1 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h1><h2 id="MybatisPlusInterceptor"><a href="#MybatisPlusInterceptor" class="headerlink" title="MybatisPlusInterceptor"></a>MybatisPlusInterceptor</h2><p>该插件是核心插件,目前代理了 <code>Executor#query</code> 和 <code>Executor#update</code> 和 <code>StatementHandler#prepare</code> 方法</p>
<h1 id="应用启动到sql-执行"><a href="#应用启动到sql-执行" class="headerlink" title="应用启动到sql 执行"></a>应用启动到sql 执行</h1>]]></content>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>启动 内置tomcat 容器 的调用链路跟踪</title>
    <url>/blog/posts/60de195c/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="启动-内置tomcat-容器-的调用链路跟踪"><a href="#启动-内置tomcat-容器-的调用链路跟踪" class="headerlink" title="启动 内置tomcat 容器 的调用链路跟踪"></a>启动 内置tomcat 容器 的调用链路跟踪</h1><p>查看<code>SpringApplication</code> 的源码, 类注释中表明 SpringApplication的定位是  自启动【也就是引导】 和 开始运行 一个Spring应用。</p>
<p>跟踪至  <code> new SpringApplication(primarySources).run(args);</code> </p>
<p>可以看到接下来的问题转化为分析  <code>SpringApplication</code> 的构造方法 和 <code>run()</code>方法，观察如何实现启动tomcat.</p>
<span id="more"></span>

<h2 id="分析构造方法"><a href="#分析构造方法" class="headerlink" title="分析构造方法"></a>分析构造方法</h2><p>在<code>SpringApplication</code>的构造方法上 的注释 说明了构造函数的作用</p>
<ol>
<li>创建一个SpringApplication的实例</li>
<li>从 primarySources 中 加载 Bean 组件</li>
<li>表明可以在运行<code>run（）</code>方法之前 定制 这个SpringApplication的实例。</li>
</ol>
<p>构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用点 this(null, primarySources);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">		Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 判断是none,servlet,reactive</span></span><br><span class="line">		<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 动态的设置SpringApplication 的 initializers 属性</span></span><br><span class="line">    <span class="comment">// private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span></span><br><span class="line">		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 动态设置SpringApplication的 listeners 属性</span></span><br><span class="line">    <span class="comment">// private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span></span><br><span class="line">		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">		<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationContextInitializer-扮演了怎样的角色"><a href="#ApplicationContextInitializer-扮演了怎样的角色" class="headerlink" title="ApplicationContextInitializer 扮演了怎样的角色"></a>ApplicationContextInitializer 扮演了怎样的角色</h3><p>查看接口注释，可知 此接口 是 代表 <strong>初始化</strong>  <code>ConfigurableApplicationContext </code>的回调接口，   并且在<code>ConfigurableApplicationContext</code> 的 <code>refresh()</code> 运行之前调用。</p>
<h3 id="ApplicationListener-扮演的角色"><a href="#ApplicationListener-扮演的角色" class="headerlink" title="ApplicationListener 扮演的角色"></a>ApplicationListener 扮演的角色</h3><p>查看接口注释，可知是代表的是 用于处理 <strong>应用事件</strong> 的 监听器。</p>
<h4 id="默认加载的几个Listener的分析"><a href="#默认加载的几个Listener的分析" class="headerlink" title="默认加载的几个Listener的分析"></a>默认加载的几个Listener的分析</h4><table>
<thead>
<tr>
<th>Listener</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>org.springframework.boot.ClearCachesApplicationListener</td>
<td>用于加载上下文之后执行清理缓存的操作，监听事件是<code>ContextRefreshedEvent</code></td>
</tr>
<tr>
<td>org.springframework.boot.builder.ParentContextCloserApplicationListener</td>
<td>监听<code>ParentContextAvailableEvent</code>, 用于当父级上下文关闭时，关闭当前上下文</td>
</tr>
<tr>
<td>org.springframework.boot.context.FileEncodingApplicationListener</td>
<td>监听<code> ApplicationEnvironmentPreparedEvent</code> 事件，当文件的编码格式不等于指定的格式时，停止应用的启动</td>
</tr>
<tr>
<td>org.springframework.boot.context.config.ConfigFileApplicationListener</td>
<td>监听<code>ApplicationEnvironmentPreparedEvent</code> ，<code>ApplicationPreparedEvent</code>事件，用于从指定的位置加载属性或者是配置文件</td>
</tr>
<tr>
<td>org.springframework.boot.context.config.DelegatingApplicationListener</td>
<td>将监听的事件 委托给在context.listener.classes环境属性下指定的其他侦听器</td>
</tr>
</tbody></table>
<h2 id="分析-run-方法"><a href="#分析-run-方法" class="headerlink" title="分析 run()方法"></a>分析 <code>run()</code>方法</h2><p>方法注释表明的功能</p>
<ol>
<li>运行这个Spring 应用程序</li>
<li>Creating and refreshing a new <code>ApplicationContext</code> </li>
<li>返回一个运行中的 <code>ApplicationContext</code></li>
</ol>
<p><code>run()</code>的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// args 通常是由命令行传递的参数	</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于程序耗时的计算</span></span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">    </span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//绘制图形用户界面相关 ，忽略</span></span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">//下面是run()方法真正的执行区域</span></span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//命令行参数的包装</span></span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">      <span class="comment">// 读取外部配置属性 命令行参数等</span></span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">      <span class="comment">// web环境 返回值类型为 AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">					<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">      <span class="comment">//加载极少数的Bean 到上下文中，可以通过 context.getBeanFactory().getBeanDefinitionNames() 近似查看，</span></span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      <span class="comment">//Load or refresh the persistent representation of the configuration,此方法执行完成之后所有的Bean都被实例化了，可以通过context.getBeanFactory().getBeanDefinitionNames() 近似观测</span></span><br><span class="line">      <span class="comment">//refresh 的语义：As this is a startup method, it should destroy already created singletons if it fails, to avoid dangling resources. In other words, after invocation of that method, either all or no singletons at all should be instantiated. </span></span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">      <span class="comment">// 结束计时</span></span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// run 的逻辑执行完成</span></span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码中涉及的相关类的角色分析"><a href="#代码中涉及的相关类的角色分析" class="headerlink" title="代码中涉及的相关类的角色分析"></a>代码中涉及的相关类的角色分析</h3><h4 id="分析AnnotationConfigServletWebServerApplicationContext的角色"><a href="#分析AnnotationConfigServletWebServerApplicationContext的角色" class="headerlink" title="分析AnnotationConfigServletWebServerApplicationContext的角色"></a>分析<code>AnnotationConfigServletWebServerApplicationContext</code>的角色</h4><p>类图如下,通过类图的 <strong>继承路线</strong> 可知，扮演的角色</p>
<ol>
<li>提供对WebServer的支持</li>
<li>提供Servlet 的支持</li>
<li>Bean的支持</li>
<li>提供对以上两者的可配置支持</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/ClassAnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p>
<p>Protect可见下，相关类属性分布</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/protect_prop_AnnotationConfigServletWebServerApplicationContext.png" alt="prop_AnnotationConfigServletWebServerApplicationContext"></p>
<p>Protect 可见下 ，相关类函数分布如下</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/protect_AnnotationConfigServletWebServerApplicationContext.png" alt="method_AnnotationConfigServletWebServerApplicationContext"></p>
<h4 id="分析ConfigurableApplicationContext-扮演的角色"><a href="#分析ConfigurableApplicationContext-扮演的角色" class="headerlink" title="分析ConfigurableApplicationContext 扮演的角色"></a>分析ConfigurableApplicationContext 扮演的角色</h4><p>类图如下</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/ConfigurableApplicationContext.png" alt="截屏2021-05-12 上午12.27.23"></p>
<p>观察接口注释，可以看出，此接口的实现类的功能是</p>
<ol>
<li>提供了配置应用上下文的功能 ，添加 应用事件监听器 到上下文中，注册 协议解析器到上下文中，添加BeanFactory的后置处理器，加载和刷新 配置文件(在这一过程完成后，上下文中的所有Bean都已经实例化完成了)，设置父级上下文，配置上下文的环境。</li>
<li>包含了 ApplicationContext 的 所有功能  </li>
</ol>
<h4 id="分析-ApplciationContext的角色"><a href="#分析-ApplciationContext的角色" class="headerlink" title="分析 ApplciationContext的角色"></a>分析 <code>ApplciationContext</code>的角色</h4><p>查看接口注释，可知，此接口的地位 是 为应用 提供配置 的核心接口。具体功能角色,由类图可知包含</p>
<ol>
<li>BeanFactory 的功能</li>
<li>MessageSource的功能</li>
<li>ResourceLoader的功能</li>
<li>应用事件发布者的功能</li>
</ol>
<h5 id="BeanFactory，ListableBeanFactory-扮演的角色"><a href="#BeanFactory，ListableBeanFactory-扮演的角色" class="headerlink" title="BeanFactory，ListableBeanFactory 扮演的角色"></a><code>BeanFactory</code>，<code>ListableBeanFactory </code>扮演的角色</h5><p>查看类注释，可知BeanFactory 的角色</p>
<ol>
<li> 作为bean的 容纳器</li>
<li>通过条件查询bean 是否在容器中</li>
<li>ListableBeanFactory在前两者的基础上增加了枚举当前工厂内所有bean的功能。</li>
</ol>
<h5 id="MessageSource-扮演的角色"><a href="#MessageSource-扮演的角色" class="headerlink" title="MessageSource 扮演的角色"></a><code>MessageSource</code> 扮演的角色</h5><p>用于支持国际化</p>
<h5 id="ResourceLoader-扮演的角色"><a href="#ResourceLoader-扮演的角色" class="headerlink" title="ResourceLoader 扮演的角色"></a><code>ResourceLoader</code> 扮演的角色</h5><p>用于从类路径下或者是制定文件加载资源。</p>
<h4 id="分析SpringApplicationRunListeners的角色"><a href="#分析SpringApplicationRunListeners的角色" class="headerlink" title="分析SpringApplicationRunListeners的角色"></a>分析<code>SpringApplicationRunListeners</code>的角色</h4><p>查看源码，可以看到是 <code>SpringApplicationRunListener</code>的集合。<code>SpringApplicationRunListener</code> 扮演的角色，由源码可知</p>
<ol>
<li>监听 <code>SpringApplication</code>的run() 方法 中发布的事件</li>
</ol>
<p>监听一个方法，是不是很奇怪呢。</p>
<table>
<thead>
<tr>
<th>Run 中监听的事件</th>
<th>发布事件的时机</th>
</tr>
</thead>
<tbody><tr>
<td>starting</td>
<td>SpringApplication 的 run() 方法 真正开始执行时</td>
</tr>
<tr>
<td>environmentPrepared</td>
<td>读取完 外部属性值和参数 后</td>
</tr>
<tr>
<td>contextPrepared</td>
<td>上下文 中的 ApplicationContextInitializer 执行完 initialize() 方法 后</td>
</tr>
<tr>
<td>contextLoaded</td>
<td>上下文需要的 Bean 单例 生成完毕，并且加载到了应用上下文 之后</td>
</tr>
<tr>
<td>started</td>
<td>上下文执行refresh() 完成之后</td>
</tr>
<tr>
<td>running</td>
<td>CommandLineRunner 和 ApplicationRunners 完成调用之后</td>
</tr>
</tbody></table>
<h4 id="分析ApplicationArguments的角色"><a href="#分析ApplicationArguments的角色" class="headerlink" title="分析ApplicationArguments的角色"></a>分析<code>ApplicationArguments</code>的角色</h4><p>包装了命令行参数</p>
<h4 id="分析ConfigurableEnvironment的角色"><a href="#分析ConfigurableEnvironment的角色" class="headerlink" title="分析ConfigurableEnvironment的角色"></a>分析<code>ConfigurableEnvironment</code>的角色</h4><p>类图如下，主要用于读取 ，命令行 以及 配置文件等外部化配置的属性的读取。 如 .profile 等。</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/ConfiguarableEnviorment.png" alt="截屏2021-05-12 下午3.37.56"></p>
<p> 通过对<code>run()方法的解读</code>，最终关键操作在<code>refreshContext()</code> 中执行</p>
<h2 id="分析refresh"><a href="#分析refresh" class="headerlink" title="分析refresh()"></a>分析<code>refresh()</code></h2><p><code>ConfigurableApplicationContext</code> 的 <code>refresh()</code> 的函数注释上，表明此函数的目的是完成所有Bean的实例化。源码如下，分析在代码中已经注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">     <span class="comment">// Prepare this context for refreshing, setting its startup date and active flag as well as performing any initialization of property sources.</span></span><br><span class="line">     <span class="comment">// Replace  Servlet-related property sources.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">     <span class="comment">// 绑定一个id 到 应用上下文的 DefaultListableBeanFactory 上</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">     <span class="comment">// Configure the factory&#x27;s standard context characteristics such as the context&#x27;s ClassLoader and post-processors.对BeanFactory 进行设置，以满足上下文的要求</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses. Modify the application context&#x27;s internal bean factory after its standard initialization. All bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for registering special BeanPostProcessors etc in certain ApplicationContext implementations. </span></span><br><span class="line">       <span class="comment">// 所有的Bean定义已经加载，但是还未实例化。是一个对Spring 内置的 BeanFactory 进行扩展的一个点，可以在这里配置BeanFactory。</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        <span class="comment">// 调用 上下文中 的 beanFactory 的 处理器，也就是实例化 并且 调用了所有的 BeanFactoryPostProcessors，这一过程必须在 单例 实例化之前调用</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation. 注册参与Bean创建的处理器</span></span><br><span class="line">       <span class="comment">// instantiate and register all BeanPostProcessor beans ，对Bean 的后置处理器进行注册和实例化 ，这一过程必须在Bean 实例化之前调用</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context. 忽略</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context. 忽略</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">       <span class="comment">//在实例化单例之前调用，用于实例化一些特殊的Bean。通过打断点观察 this，发现说的特殊类型的Bean 指的是与webServer,servletContext,themeSource, environment 等相关的Bean</span></span><br><span class="line">			onRefresh();</span><br><span class="line">     </span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">       <span class="comment">// 添加实现了ApplicationListener 的 Bean</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">       <span class="comment">//将 单例Bean 进行实例化</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">       <span class="comment">// Finish the refresh of this context, invoking the LifecycleProcessor&#x27;s onRefresh() method and publishing the org.springframework.context.event.ContextRefreshedEvent</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从分析中可以看出，<code>onRefresh()</code>方法是由启动Tomcat 容器相关的类。</p>
<h3 id="分析BeanFactoryPostProcessor"><a href="#分析BeanFactoryPostProcessor" class="headerlink" title="分析BeanFactoryPostProcessor"></a>分析BeanFactoryPostProcessor</h3><p> 地位：Factory hook that allows for custom modification of an application context’s  <strong>bean definitions</strong>, adapting the bean property values of the context’s underlying bean factory. 可知是对上下文中的BeanDefinition 进行操作。</p>
<h3 id="分析BeanPostProcessor"><a href="#分析BeanPostProcessor" class="headerlink" title="分析BeanPostProcessor"></a>分析BeanPostProcessor</h3><p>Factory hook that allows for custom modification of  <strong>new bean</strong> instances — for example, checking for marker interfaces or wrapping beans with proxies. </p>
<p>post-processors that populate beans via marker interfaces or the like will implement <code> postProcessBeforeInitialization</code></p>
<p> post-processors that wrap beans with proxies will normally implement<code> postProcessAfterInitialization</code></p>
<h2 id="分析onRefresh"><a href="#分析onRefresh" class="headerlink" title="分析onRefresh"></a>分析<code>onRefresh</code></h2><p>这里需要注意到 执行当前方法的对象 是 <code>AnnotationConfigServletWebServerApplicationContext</code> 的 一个实例。因此分析此类的<code>onRefresh（）</code>方法。通过上面的带有方法的类图，我们看到方法的位置是在 <code>ServletWebServerApplicationContext</code> 中。查看此方法,便知 需要进一步分析的是<code>createWebServer()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">	ServletContext servletContext = getServletContext();</span><br><span class="line">	<span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">		ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">		<span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			getSelfInitializer().onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，下一步的任务就是查看分析<code>getWebServer()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">      Registry.disableRegistry();</span><br><span class="line">   &#125;</span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory : createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   connector.setThrowOnFailure(<span class="keyword">true</span>);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//前面是对tomcat 实例 的基本配置</span></span><br><span class="line">  </span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查看方法注释，Factory method called to create the &#123;@link TomcatWebServer&#125; </span></span><br><span class="line">  <span class="comment">//表明了这里是创建WebServer的地方，也是tomcat 的顶层容器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>getTomcatWebServer()</code>方法，便知下一步分析的方法是<code>TomcatWebServer</code>的构造方法。查看该类构造方法，继而跟进到<code>initialize()</code>，显然在这里启动了tomcat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">   logger.info(<span class="string">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class="keyword">false</span>));</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         addInstanceIdToEngineName();</span><br><span class="line"></span><br><span class="line">         Context context = findContext();</span><br><span class="line">         context.addLifecycleListener((event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">               <span class="comment">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class="line">               <span class="comment">// happen when the service is started.</span></span><br><span class="line">               removeServiceConnectors();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Start the server to trigger initialization listeners</span></span><br><span class="line">         <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// We can re-throw failure exception directly in the main thread</span></span><br><span class="line">         rethrowDeferredStartupExceptions();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">            <span class="comment">// Naming is not enabled. Continue</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class="line">         <span class="comment">// blocking non-daemon to stop immediate shutdown</span></span><br><span class="line">         startDaemonAwaitThread();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         stopSilently();</span><br><span class="line">         destroySilently();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>查看源代码时，尤其是继承关系复杂的时候，第一个就是确定当前执行当前方法的真正类型。第二，需要看protect下的类图，这样就不会跟丢方法，而且会加深理解继承层次间的不同。</p>
</li>
<li><p>提问题，以及打断点，观察相应节点的状态，有助于帮助我们分析问题。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>源码跟踪</tag>
      </tags>
  </entry>
</search>
