<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>启动 内置tomcat 容器 的调用链路跟踪</title>
    <url>/blog/posts/60de195c/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="启动-内置tomcat-容器-的调用链路跟踪"><a href="#启动-内置tomcat-容器-的调用链路跟踪" class="headerlink" title="启动 内置tomcat 容器 的调用链路跟踪"></a>启动 内置tomcat 容器 的调用链路跟踪</h1><p>查看<code>SpringApplication</code> 的源码, 类注释中表明 SpringApplication的定位是  自启动【也就是引导】 和 开始运行 一个Spring应用。</p>
<p>跟踪至  <code> new SpringApplication(primarySources).run(args);</code> </p>
<p>可以看到接下来的问题转化为分析  <code>SpringApplication</code> 的构造方法 和 <code>run()</code>方法，观察如何实现启动tomcat.</p>
<span id="more"></span>

<h2 id="分析构造方法"><a href="#分析构造方法" class="headerlink" title="分析构造方法"></a>分析构造方法</h2><p>在<code>SpringApplication</code>的构造方法上 的注释 说明了构造函数的作用</p>
<ol>
<li>创建一个SpringApplication的实例</li>
<li>从 primarySources 中 加载 Bean 组件</li>
<li>表明可以在运行<code>run（）</code>方法之前 定制 这个SpringApplication的实例。</li>
</ol>
<p>构造函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用点 this(null, primarySources);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">		Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 判断是none,servlet,reactive</span></span><br><span class="line">		<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 动态的设置SpringApplication 的 initializers 属性</span></span><br><span class="line">    <span class="comment">// private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span></span><br><span class="line">		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 动态设置SpringApplication的 listeners 属性</span></span><br><span class="line">    <span class="comment">// private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span></span><br><span class="line">		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">		<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationContextInitializer-扮演了怎样的角色"><a href="#ApplicationContextInitializer-扮演了怎样的角色" class="headerlink" title="ApplicationContextInitializer 扮演了怎样的角色"></a>ApplicationContextInitializer 扮演了怎样的角色</h3><p>查看接口注释，可知 此接口 是 代表 <strong>初始化</strong>  <code>ConfigurableApplicationContext </code>的回调接口，   并且在<code>ConfigurableApplicationContext</code> 的 <code>refresh()</code> 运行之前调用。</p>
<h3 id="ApplicationListener-扮演的角色"><a href="#ApplicationListener-扮演的角色" class="headerlink" title="ApplicationListener 扮演的角色"></a>ApplicationListener 扮演的角色</h3><p>查看接口注释，可知是代表的是 用于处理 <strong>应用事件</strong> 的 监听器。</p>
<h2 id="分析-run-方法"><a href="#分析-run-方法" class="headerlink" title="分析 run()方法"></a>分析 <code>run()</code>方法</h2><p>方法注释表明的功能</p>
<ol>
<li>运行这个Spring 应用程序</li>
<li>Creating and refreshing a new <code>ApplicationContext</code> </li>
<li>返回一个运行中的 <code>ApplicationContext</code></li>
</ol>
<p><code>run()</code>的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// args 通常是由命令行传递的参数	</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于程序耗时的计算</span></span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">    </span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//绘制图形用户界面相关 ，忽略</span></span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  <span class="comment">//下面是run()方法真正的执行区域</span></span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//命令行参数的包装</span></span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">      <span class="comment">// 读取外部配置属性 命令行参数等</span></span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">      <span class="comment">// web环境 返回值类型为 AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">					<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">      <span class="comment">//加载极少数的Bean 到上下文中，可以通过 context.getBeanFactory().getBeanDefinitionNames() 近似查看，</span></span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      <span class="comment">//Load or refresh the persistent representation of the configuration,此方法执行完成之后所有的Bean都被实例化了，可以通过context.getBeanFactory().getBeanDefinitionNames() 近似观测</span></span><br><span class="line">      <span class="comment">//refresh 的语义：As this is a startup method, it should destroy already created singletons if it fails, to avoid dangling resources. In other words, after invocation of that method, either all or no singletons at all should be instantiated. </span></span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">      <span class="comment">// 结束计时</span></span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// run 的逻辑执行完成</span></span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码中涉及的相关类的角色分析"><a href="#代码中涉及的相关类的角色分析" class="headerlink" title="代码中涉及的相关类的角色分析"></a>代码中涉及的相关类的角色分析</h3><h4 id="分析AnnotationConfigServletWebServerApplicationContext的角色"><a href="#分析AnnotationConfigServletWebServerApplicationContext的角色" class="headerlink" title="分析AnnotationConfigServletWebServerApplicationContext的角色"></a>分析<code>AnnotationConfigServletWebServerApplicationContext</code>的角色</h4><p>类图如下,通过类图的 <strong>继承路线</strong> 可知，扮演的角色</p>
<ol>
<li>提供对WebServer的支持</li>
<li>提供Servlet 的支持</li>
<li>Bean的支持</li>
<li>提供对以上两者的可配置支持</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/ClassAnnotationConfigServletWebServerApplicationContext.png" alt="AnnotationConfigServletWebServerApplicationContext"></p>
<p>Protect可见下，相关类属性分布</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/protect_prop_AnnotationConfigServletWebServerApplicationContext.png" alt="prop_AnnotationConfigServletWebServerApplicationContext"></p>
<p>Protect 可见下 ，相关类函数分布如下</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/protect_AnnotationConfigServletWebServerApplicationContext.png" alt="method_AnnotationConfigServletWebServerApplicationContext"></p>
<h4 id="分析ConfigurableApplicationContext-扮演的角色"><a href="#分析ConfigurableApplicationContext-扮演的角色" class="headerlink" title="分析ConfigurableApplicationContext 扮演的角色"></a>分析ConfigurableApplicationContext 扮演的角色</h4><p>类图如下</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/ConfigurableApplicationContext.png" alt="截屏2021-05-12 上午12.27.23"></p>
<p>观察接口注释，可以看出，此接口的实现类的功能是</p>
<ol>
<li>提供了配置应用上下文的功能 ，添加 应用事件监听器 到上下文中，注册 协议解析器到上下文中，添加BeanFactory的后置处理器，加载和刷新 配置文件(在这一过程完成后，上下文中的所有Bean都已经实例化完成了)，设置父级上下文，配置上下文的环境。</li>
<li>包含了 ApplicationContext 的 所有功能  </li>
</ol>
<h4 id="分析-ApplciationContext的角色"><a href="#分析-ApplciationContext的角色" class="headerlink" title="分析 ApplciationContext的角色"></a>分析 <code>ApplciationContext</code>的角色</h4><p>查看接口注释，可知，此接口的地位 是 为应用 提供配置 的核心接口。具体功能角色,由类图可知包含</p>
<ol>
<li>BeanFactory 的功能</li>
<li>MessageSource的功能</li>
<li>ResourceLoader的功能</li>
<li>应用事件发布者的功能</li>
</ol>
<h5 id="BeanFactory，ListableBeanFactory-扮演的角色"><a href="#BeanFactory，ListableBeanFactory-扮演的角色" class="headerlink" title="BeanFactory，ListableBeanFactory 扮演的角色"></a><code>BeanFactory</code>，<code>ListableBeanFactory </code>扮演的角色</h5><p>查看类注释，可知BeanFactory 的角色</p>
<ol>
<li> 作为bean的 容纳器</li>
<li>通过条件查询bean 是否在容器中</li>
<li>ListableBeanFactory在前两者的基础上增加了枚举当前工厂内所有bean的功能。</li>
</ol>
<h5 id="MessageSource-扮演的角色"><a href="#MessageSource-扮演的角色" class="headerlink" title="MessageSource 扮演的角色"></a><code>MessageSource</code> 扮演的角色</h5><p>用于支持国际化</p>
<h5 id="ResourceLoader-扮演的角色"><a href="#ResourceLoader-扮演的角色" class="headerlink" title="ResourceLoader 扮演的角色"></a><code>ResourceLoader</code> 扮演的角色</h5><p>用于从类路径下或者是制定文件加载资源。</p>
<h4 id="分析SpringApplicationRunListeners的角色"><a href="#分析SpringApplicationRunListeners的角色" class="headerlink" title="分析SpringApplicationRunListeners的角色"></a>分析<code>SpringApplicationRunListeners</code>的角色</h4><p>查看源码，可以看到是 <code>SpringApplicationRunListener</code>的集合。<code>SpringApplicationRunListener</code> 扮演的角色，由源码可知</p>
<ol>
<li>监听 <code>SpringApplication</code>的run() 方法 中发布的事件</li>
</ol>
<p>监听一个方法，是不是很奇怪呢。</p>
<table>
<thead>
<tr>
<th>Run 中监听的事件</th>
<th>发布事件的时机</th>
</tr>
</thead>
<tbody><tr>
<td>starting</td>
<td>SpringApplication 的 run() 方法 真正开始执行时</td>
</tr>
<tr>
<td>environmentPrepared</td>
<td>读取完 外部属性值和参数 后</td>
</tr>
<tr>
<td>contextPrepared</td>
<td>上下文 中的 ApplicationContextInitializer 执行完 initialize() 方法 后</td>
</tr>
<tr>
<td>contextLoaded</td>
<td>上下文需要的 Bean 单例 生成完毕，并且加载到了应用上下文 之后</td>
</tr>
<tr>
<td>started</td>
<td>上下文执行refresh() 完成之后</td>
</tr>
<tr>
<td>running</td>
<td>CommandLineRunner 和 ApplicationRunners 完成调用之后</td>
</tr>
</tbody></table>
<h4 id="分析ApplicationArguments的角色"><a href="#分析ApplicationArguments的角色" class="headerlink" title="分析ApplicationArguments的角色"></a>分析<code>ApplicationArguments</code>的角色</h4><p>包装了命令行参数</p>
<h4 id="分析ConfigurableEnvironment的角色"><a href="#分析ConfigurableEnvironment的角色" class="headerlink" title="分析ConfigurableEnvironment的角色"></a>分析<code>ConfigurableEnvironment</code>的角色</h4><p>类图如下，主要用于读取 ，命令行 以及 配置文件等外部化配置的属性的读取。 如 .profile 等。</p>
<p><img src="https://raw.githubusercontent.com/LIngcheng-zeng/picture/master/blog/ConfiguarableEnviorment.png" alt="截屏2021-05-12 下午3.37.56"></p>
<p> 通过对<code>run()方法的解读</code>，最终关键操作在<code>refreshContext()</code> 中执行</p>
<h2 id="分析refresh"><a href="#分析refresh" class="headerlink" title="分析refresh()"></a>分析<code>refresh()</code></h2><p><code>ConfigurableApplicationContext</code> 的 <code>refresh()</code> 的函数注释上，表明此函数的目的是完成所有Bean的实例化。源码如下，分析在代码中已经注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">     </span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">     <span class="comment">// 对BeanFactory 进行设置，以满足上下文的要求</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">       <span class="comment">// 所有的Bean定义已经加载，但是还未实例化。是一个对Spring 内置的工厂Bean 进行扩展的一个点。</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">       <span class="comment">//实例化 并且调用所有的 BeanFactoryPostProcessors，必须在单例 实例化之前调用</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">       <span class="comment">// instantiate and register all BeanPostProcessor beans ，必须在应用的Bean 实例化之前调用</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context. 忽略</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context. 忽略</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">       <span class="comment">//在实例化单例之前调用，用于实例化一些特殊的Bean。通过打断点观察 this，发现说的特殊类型的Bean 指的是与webServer,servletContext,themeSource, environment 等相关的Bean</span></span><br><span class="line">			onRefresh();</span><br><span class="line">     </span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">       <span class="comment">// 添加实现了ApplicationListener 的 Bean</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">       <span class="comment">//将单例Bean进行实例化</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">       <span class="comment">// Finish the refresh of this context, invoking the LifecycleProcessor&#x27;s onRefresh() method and publishing the org.springframework.context.event.ContextRefreshedEvent</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从分析中可以看出，<code>onRefresh()</code>方法是由启动Tomcat 容器相关的类。</p>
<h2 id="分析onRefresh"><a href="#分析onRefresh" class="headerlink" title="分析onRefresh"></a>分析<code>onRefresh</code></h2><p>这里需要注意到 执行当前方法的对象 是 <code>AnnotationConfigServletWebServerApplicationContext</code> 的 一个实例。因此分析此类的<code>onRefresh（）</code>方法。通过上面的带有方法的类图，我们看到方法的位置是在 <code>ServletWebServerApplicationContext</code> 中。查看此方法,便知 需要进一步分析的是<code>createWebServer()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">	ServletContext servletContext = getServletContext();</span><br><span class="line">	<span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">		ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">		<span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			getSelfInitializer().onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，下一步的任务就是查看分析<code>getWebServer()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.disableMBeanRegistry) &#123;</span><br><span class="line">      Registry.disableRegistry();</span><br><span class="line">   &#125;</span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span>) ? <span class="keyword">this</span>.baseDirectory : createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   connector.setThrowOnFailure(<span class="keyword">true</span>);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//前面是对tomcat 实例 的基本配置</span></span><br><span class="line">  </span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查看方法注释，Factory method called to create the &#123;@link TomcatWebServer&#125; </span></span><br><span class="line">  <span class="comment">//表明了这里是创建WebServer的地方，也是tomcat 的顶层容器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>getTomcatWebServer()</code>方法，便知下一步分析的方法是<code>TomcatWebServer</code>的构造方法。查看该类构造方法，继而跟进到<code>initialize()</code>，显然在这里启动了tomcat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException </span>&#123;</span><br><span class="line">   logger.info(<span class="string">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class="keyword">false</span>));</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         addInstanceIdToEngineName();</span><br><span class="line"></span><br><span class="line">         Context context = findContext();</span><br><span class="line">         context.addLifecycleListener((event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">               <span class="comment">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class="line">               <span class="comment">// happen when the service is started.</span></span><br><span class="line">               removeServiceConnectors();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Start the server to trigger initialization listeners</span></span><br><span class="line">         <span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// We can re-throw failure exception directly in the main thread</span></span><br><span class="line">         rethrowDeferredStartupExceptions();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">            <span class="comment">// Naming is not enabled. Continue</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class="line">         <span class="comment">// blocking non-daemon to stop immediate shutdown</span></span><br><span class="line">         startDaemonAwaitThread();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         stopSilently();</span><br><span class="line">         destroySilently();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> WebServerException(<span class="string">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>查看源代码时，尤其是继承关系复杂的时候，第一个就是确定当前执行当前方法的真正类型。第二，需要看protect下的类图，这样就不会跟丢方法，而且会加深理解继承层次间的不同。</li>
<li>提问题，以及打断点，观察相应节点的状态，有助于帮助我们分析问题。</li>
</ol>
]]></content>
      <tags>
        <tag>源码跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
